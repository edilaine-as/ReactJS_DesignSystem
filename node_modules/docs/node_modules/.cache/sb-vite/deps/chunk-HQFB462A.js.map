{
  "version": 3,
  "sources": ["../../../../../../node_modules/doctrine/package.json", "../../../../../../node_modules/browser-assert/lib/assert.js", "../../../../../../node_modules/doctrine/lib/utility.js", "../../../../../../node_modules/doctrine/lib/typed.js", "../../../../../../node_modules/doctrine/lib/doctrine.js"],
  "sourcesContent": ["{\r\n  \"name\": \"doctrine\",\r\n  \"description\": \"JSDoc parser\",\r\n  \"homepage\": \"https://github.com/eslint/doctrine\",\r\n  \"main\": \"lib/doctrine.js\",\r\n  \"version\": \"3.0.0\",\r\n  \"engines\": {\r\n    \"node\": \">=6.0.0\"\r\n  },\r\n  \"directories\": {\r\n    \"lib\": \"./lib\"\r\n  },\r\n  \"files\": [\r\n    \"lib\"\r\n  ],\r\n  \"maintainers\": [\r\n    {\r\n      \"name\": \"Nicholas C. Zakas\",\r\n      \"email\": \"nicholas+npm@nczconsulting.com\",\r\n      \"web\": \"https://www.nczonline.net\"\r\n    },\r\n    {\r\n      \"name\": \"Yusuke Suzuki\",\r\n      \"email\": \"utatane.tea@gmail.com\",\r\n      \"web\": \"https://github.com/Constellation\"\r\n    }\r\n  ],\r\n  \"repository\": \"eslint/doctrine\",\r\n  \"devDependencies\": {\r\n    \"coveralls\": \"^3.0.1\",\r\n    \"dateformat\": \"^1.0.11\",\r\n    \"eslint\": \"^1.10.3\",\r\n    \"eslint-release\": \"^1.0.0\",\r\n    \"linefix\": \"^0.1.1\",\r\n    \"mocha\": \"^3.4.2\",\r\n    \"npm-license\": \"^0.3.1\",\r\n    \"nyc\": \"^10.3.2\",\r\n    \"semver\": \"^5.0.3\",\r\n    \"shelljs\": \"^0.5.3\",\r\n    \"shelljs-nodecli\": \"^0.1.1\",\r\n    \"should\": \"^5.0.1\"\r\n  },\r\n  \"license\": \"Apache-2.0\",\r\n  \"scripts\": {\r\n    \"pretest\": \"npm run lint\",\r\n    \"test\": \"nyc mocha\",\r\n    \"coveralls\": \"nyc report --reporter=text-lcov | coveralls\",\r\n    \"lint\": \"eslint lib/\",\r\n    \"generate-release\": \"eslint-generate-release\",\r\n    \"generate-alpharelease\": \"eslint-generate-prerelease alpha\",\r\n    \"generate-betarelease\": \"eslint-generate-prerelease beta\",\r\n    \"generate-rcrelease\": \"eslint-generate-prerelease rc\",\r\n    \"publish-release\": \"eslint-publish-release\"\r\n  },\r\n  \"dependencies\": {\r\n    \"esutils\": \"^2.0.2\"\r\n  }\r\n}\r\n", "function assert(expr, message) {\n  if(!Boolean(expr)) {\n    throw new Error(message || 'unknown assertion error');\n  }\n}\n\nmodule.exports = assert;\n", "/*\r\n * @fileoverview Utilities for Doctrine\r\n * @author Yusuke Suzuki <utatane.tea@gmail.com>\r\n */\r\n\r\n\r\n(function () {\r\n    'use strict';\r\n\r\n    var VERSION;\r\n\r\n    VERSION = require('../package.json').version;\r\n    exports.VERSION = VERSION;\r\n\r\n    function DoctrineError(message) {\r\n        this.name = 'DoctrineError';\r\n        this.message = message;\r\n    }\r\n    DoctrineError.prototype = (function () {\r\n        var Middle = function () { };\r\n        Middle.prototype = Error.prototype;\r\n        return new Middle();\r\n    }());\r\n    DoctrineError.prototype.constructor = DoctrineError;\r\n    exports.DoctrineError = DoctrineError;\r\n\r\n    function throwError(message) {\r\n        throw new DoctrineError(message);\r\n    }\r\n    exports.throwError = throwError;\r\n\r\n    exports.assert = require('assert');\r\n}());\r\n\r\n/* vim: set sw=4 ts=4 et tw=80 : */\r\n", "/*\r\n * @fileoverview Type expression parser.\r\n * @author Yusuke Suzuki <utatane.tea@gmail.com>\r\n * @author Dan Tao <daniel.tao@gmail.com>\r\n * @author Andrew Eisenberg <andrew@eisenberg.as>\r\n */\r\n\r\n// \"typed\", the Type Expression Parser for doctrine.\r\n\r\n(function () {\r\n    'use strict';\r\n\r\n    var Syntax,\r\n        Token,\r\n        source,\r\n        length,\r\n        index,\r\n        previous,\r\n        token,\r\n        value,\r\n        esutils,\r\n        utility,\r\n        rangeOffset,\r\n        addRange;\r\n\r\n    esutils = require('esutils');\r\n    utility = require('./utility');\r\n\r\n    Syntax = {\r\n        NullableLiteral: 'NullableLiteral',\r\n        AllLiteral: 'AllLiteral',\r\n        NullLiteral: 'NullLiteral',\r\n        UndefinedLiteral: 'UndefinedLiteral',\r\n        VoidLiteral: 'VoidLiteral',\r\n        UnionType: 'UnionType',\r\n        ArrayType: 'ArrayType',\r\n        RecordType: 'RecordType',\r\n        FieldType: 'FieldType',\r\n        FunctionType: 'FunctionType',\r\n        ParameterType: 'ParameterType',\r\n        RestType: 'RestType',\r\n        NonNullableType: 'NonNullableType',\r\n        OptionalType: 'OptionalType',\r\n        NullableType: 'NullableType',\r\n        NameExpression: 'NameExpression',\r\n        TypeApplication: 'TypeApplication',\r\n        StringLiteralType: 'StringLiteralType',\r\n        NumericLiteralType: 'NumericLiteralType',\r\n        BooleanLiteralType: 'BooleanLiteralType'\r\n    };\r\n\r\n    Token = {\r\n        ILLEGAL: 0,    // ILLEGAL\r\n        DOT_LT: 1,     // .<\r\n        REST: 2,       // ...\r\n        LT: 3,         // <\r\n        GT: 4,         // >\r\n        LPAREN: 5,     // (\r\n        RPAREN: 6,     // )\r\n        LBRACE: 7,     // {\r\n        RBRACE: 8,     // }\r\n        LBRACK: 9,    // [\r\n        RBRACK: 10,    // ]\r\n        COMMA: 11,     // ,\r\n        COLON: 12,     // :\r\n        STAR: 13,      // *\r\n        PIPE: 14,      // |\r\n        QUESTION: 15,  // ?\r\n        BANG: 16,      // !\r\n        EQUAL: 17,     // =\r\n        NAME: 18,      // name token\r\n        STRING: 19,    // string\r\n        NUMBER: 20,    // number\r\n        EOF: 21\r\n    };\r\n\r\n    function isTypeName(ch) {\r\n        return '><(){}[],:*|?!='.indexOf(String.fromCharCode(ch)) === -1 && !esutils.code.isWhiteSpace(ch) && !esutils.code.isLineTerminator(ch);\r\n    }\r\n\r\n    function Context(previous, index, token, value) {\r\n        this._previous = previous;\r\n        this._index = index;\r\n        this._token = token;\r\n        this._value = value;\r\n    }\r\n\r\n    Context.prototype.restore = function () {\r\n        previous = this._previous;\r\n        index = this._index;\r\n        token = this._token;\r\n        value = this._value;\r\n    };\r\n\r\n    Context.save = function () {\r\n        return new Context(previous, index, token, value);\r\n    };\r\n\r\n    function maybeAddRange(node, range) {\r\n        if (addRange) {\r\n            node.range = [range[0] + rangeOffset, range[1] + rangeOffset];\r\n        }\r\n        return node;\r\n    }\r\n\r\n    function advance() {\r\n        var ch = source.charAt(index);\r\n        index += 1;\r\n        return ch;\r\n    }\r\n\r\n    function scanHexEscape(prefix) {\r\n        var i, len, ch, code = 0;\r\n\r\n        len = (prefix === 'u') ? 4 : 2;\r\n        for (i = 0; i < len; ++i) {\r\n            if (index < length && esutils.code.isHexDigit(source.charCodeAt(index))) {\r\n                ch = advance();\r\n                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\r\n            } else {\r\n                return '';\r\n            }\r\n        }\r\n        return String.fromCharCode(code);\r\n    }\r\n\r\n    function scanString() {\r\n        var str = '', quote, ch, code, unescaped, restore; //TODO review removal octal = false\r\n        quote = source.charAt(index);\r\n        ++index;\r\n\r\n        while (index < length) {\r\n            ch = advance();\r\n\r\n            if (ch === quote) {\r\n                quote = '';\r\n                break;\r\n            } else if (ch === '\\\\') {\r\n                ch = advance();\r\n                if (!esutils.code.isLineTerminator(ch.charCodeAt(0))) {\r\n                    switch (ch) {\r\n                    case 'n':\r\n                        str += '\\n';\r\n                        break;\r\n                    case 'r':\r\n                        str += '\\r';\r\n                        break;\r\n                    case 't':\r\n                        str += '\\t';\r\n                        break;\r\n                    case 'u':\r\n                    case 'x':\r\n                        restore = index;\r\n                        unescaped = scanHexEscape(ch);\r\n                        if (unescaped) {\r\n                            str += unescaped;\r\n                        } else {\r\n                            index = restore;\r\n                            str += ch;\r\n                        }\r\n                        break;\r\n                    case 'b':\r\n                        str += '\\b';\r\n                        break;\r\n                    case 'f':\r\n                        str += '\\f';\r\n                        break;\r\n                    case 'v':\r\n                        str += '\\v';\r\n                        break;\r\n\r\n                    default:\r\n                        if (esutils.code.isOctalDigit(ch.charCodeAt(0))) {\r\n                            code = '01234567'.indexOf(ch);\r\n\r\n                            // \\0 is not octal escape sequence\r\n                            // Deprecating unused code. TODO review removal\r\n                            //if (code !== 0) {\r\n                            //    octal = true;\r\n                            //}\r\n\r\n                            if (index < length && esutils.code.isOctalDigit(source.charCodeAt(index))) {\r\n                                //TODO Review Removal octal = true;\r\n                                code = code * 8 + '01234567'.indexOf(advance());\r\n\r\n                                // 3 digits are only allowed when string starts\r\n                                // with 0, 1, 2, 3\r\n                                if ('0123'.indexOf(ch) >= 0 &&\r\n                                        index < length &&\r\n                                        esutils.code.isOctalDigit(source.charCodeAt(index))) {\r\n                                    code = code * 8 + '01234567'.indexOf(advance());\r\n                                }\r\n                            }\r\n                            str += String.fromCharCode(code);\r\n                        } else {\r\n                            str += ch;\r\n                        }\r\n                        break;\r\n                    }\r\n                } else {\r\n                    if (ch ===  '\\r' && source.charCodeAt(index) === 0x0A  /* '\\n' */) {\r\n                        ++index;\r\n                    }\r\n                }\r\n            } else if (esutils.code.isLineTerminator(ch.charCodeAt(0))) {\r\n                break;\r\n            } else {\r\n                str += ch;\r\n            }\r\n        }\r\n\r\n        if (quote !== '') {\r\n            utility.throwError('unexpected quote');\r\n        }\r\n\r\n        value = str;\r\n        return Token.STRING;\r\n    }\r\n\r\n    function scanNumber() {\r\n        var number, ch;\r\n\r\n        number = '';\r\n        ch = source.charCodeAt(index);\r\n\r\n        if (ch !== 0x2E  /* '.' */) {\r\n            number = advance();\r\n            ch = source.charCodeAt(index);\r\n\r\n            if (number === '0') {\r\n                if (ch === 0x78  /* 'x' */ || ch === 0x58  /* 'X' */) {\r\n                    number += advance();\r\n                    while (index < length) {\r\n                        ch = source.charCodeAt(index);\r\n                        if (!esutils.code.isHexDigit(ch)) {\r\n                            break;\r\n                        }\r\n                        number += advance();\r\n                    }\r\n\r\n                    if (number.length <= 2) {\r\n                        // only 0x\r\n                        utility.throwError('unexpected token');\r\n                    }\r\n\r\n                    if (index < length) {\r\n                        ch = source.charCodeAt(index);\r\n                        if (esutils.code.isIdentifierStartES5(ch)) {\r\n                            utility.throwError('unexpected token');\r\n                        }\r\n                    }\r\n                    value = parseInt(number, 16);\r\n                    return Token.NUMBER;\r\n                }\r\n\r\n                if (esutils.code.isOctalDigit(ch)) {\r\n                    number += advance();\r\n                    while (index < length) {\r\n                        ch = source.charCodeAt(index);\r\n                        if (!esutils.code.isOctalDigit(ch)) {\r\n                            break;\r\n                        }\r\n                        number += advance();\r\n                    }\r\n\r\n                    if (index < length) {\r\n                        ch = source.charCodeAt(index);\r\n                        if (esutils.code.isIdentifierStartES5(ch) || esutils.code.isDecimalDigit(ch)) {\r\n                            utility.throwError('unexpected token');\r\n                        }\r\n                    }\r\n                    value = parseInt(number, 8);\r\n                    return Token.NUMBER;\r\n                }\r\n\r\n                if (esutils.code.isDecimalDigit(ch)) {\r\n                    utility.throwError('unexpected token');\r\n                }\r\n            }\r\n\r\n            while (index < length) {\r\n                ch = source.charCodeAt(index);\r\n                if (!esutils.code.isDecimalDigit(ch)) {\r\n                    break;\r\n                }\r\n                number += advance();\r\n            }\r\n        }\r\n\r\n        if (ch === 0x2E  /* '.' */) {\r\n            number += advance();\r\n            while (index < length) {\r\n                ch = source.charCodeAt(index);\r\n                if (!esutils.code.isDecimalDigit(ch)) {\r\n                    break;\r\n                }\r\n                number += advance();\r\n            }\r\n        }\r\n\r\n        if (ch === 0x65  /* 'e' */ || ch === 0x45  /* 'E' */) {\r\n            number += advance();\r\n\r\n            ch = source.charCodeAt(index);\r\n            if (ch === 0x2B  /* '+' */ || ch === 0x2D  /* '-' */) {\r\n                number += advance();\r\n            }\r\n\r\n            ch = source.charCodeAt(index);\r\n            if (esutils.code.isDecimalDigit(ch)) {\r\n                number += advance();\r\n                while (index < length) {\r\n                    ch = source.charCodeAt(index);\r\n                    if (!esutils.code.isDecimalDigit(ch)) {\r\n                        break;\r\n                    }\r\n                    number += advance();\r\n                }\r\n            } else {\r\n                utility.throwError('unexpected token');\r\n            }\r\n        }\r\n\r\n        if (index < length) {\r\n            ch = source.charCodeAt(index);\r\n            if (esutils.code.isIdentifierStartES5(ch)) {\r\n                utility.throwError('unexpected token');\r\n            }\r\n        }\r\n\r\n        value = parseFloat(number);\r\n        return Token.NUMBER;\r\n    }\r\n\r\n\r\n    function scanTypeName() {\r\n        var ch, ch2;\r\n\r\n        value = advance();\r\n        while (index < length && isTypeName(source.charCodeAt(index))) {\r\n            ch = source.charCodeAt(index);\r\n            if (ch === 0x2E  /* '.' */) {\r\n                if ((index + 1) >= length) {\r\n                    return Token.ILLEGAL;\r\n                }\r\n                ch2 = source.charCodeAt(index + 1);\r\n                if (ch2 === 0x3C  /* '<' */) {\r\n                    break;\r\n                }\r\n            }\r\n            value += advance();\r\n        }\r\n        return Token.NAME;\r\n    }\r\n\r\n    function next() {\r\n        var ch;\r\n\r\n        previous = index;\r\n\r\n        while (index < length && esutils.code.isWhiteSpace(source.charCodeAt(index))) {\r\n            advance();\r\n        }\r\n        if (index >= length) {\r\n            token = Token.EOF;\r\n            return token;\r\n        }\r\n\r\n        ch = source.charCodeAt(index);\r\n        switch (ch) {\r\n        case 0x27:  /* ''' */\r\n        case 0x22:  /* '\"' */\r\n            token = scanString();\r\n            return token;\r\n\r\n        case 0x3A:  /* ':' */\r\n            advance();\r\n            token = Token.COLON;\r\n            return token;\r\n\r\n        case 0x2C:  /* ',' */\r\n            advance();\r\n            token = Token.COMMA;\r\n            return token;\r\n\r\n        case 0x28:  /* '(' */\r\n            advance();\r\n            token = Token.LPAREN;\r\n            return token;\r\n\r\n        case 0x29:  /* ')' */\r\n            advance();\r\n            token = Token.RPAREN;\r\n            return token;\r\n\r\n        case 0x5B:  /* '[' */\r\n            advance();\r\n            token = Token.LBRACK;\r\n            return token;\r\n\r\n        case 0x5D:  /* ']' */\r\n            advance();\r\n            token = Token.RBRACK;\r\n            return token;\r\n\r\n        case 0x7B:  /* '{' */\r\n            advance();\r\n            token = Token.LBRACE;\r\n            return token;\r\n\r\n        case 0x7D:  /* '}' */\r\n            advance();\r\n            token = Token.RBRACE;\r\n            return token;\r\n\r\n        case 0x2E:  /* '.' */\r\n            if (index + 1 < length) {\r\n                ch = source.charCodeAt(index + 1);\r\n                if (ch === 0x3C  /* '<' */) {\r\n                    advance();  // '.'\r\n                    advance();  // '<'\r\n                    token = Token.DOT_LT;\r\n                    return token;\r\n                }\r\n\r\n                if (ch === 0x2E  /* '.' */ && index + 2 < length && source.charCodeAt(index + 2) === 0x2E  /* '.' */) {\r\n                    advance();  // '.'\r\n                    advance();  // '.'\r\n                    advance();  // '.'\r\n                    token = Token.REST;\r\n                    return token;\r\n                }\r\n\r\n                if (esutils.code.isDecimalDigit(ch)) {\r\n                    token = scanNumber();\r\n                    return token;\r\n                }\r\n            }\r\n            token = Token.ILLEGAL;\r\n            return token;\r\n\r\n        case 0x3C:  /* '<' */\r\n            advance();\r\n            token = Token.LT;\r\n            return token;\r\n\r\n        case 0x3E:  /* '>' */\r\n            advance();\r\n            token = Token.GT;\r\n            return token;\r\n\r\n        case 0x2A:  /* '*' */\r\n            advance();\r\n            token = Token.STAR;\r\n            return token;\r\n\r\n        case 0x7C:  /* '|' */\r\n            advance();\r\n            token = Token.PIPE;\r\n            return token;\r\n\r\n        case 0x3F:  /* '?' */\r\n            advance();\r\n            token = Token.QUESTION;\r\n            return token;\r\n\r\n        case 0x21:  /* '!' */\r\n            advance();\r\n            token = Token.BANG;\r\n            return token;\r\n\r\n        case 0x3D:  /* '=' */\r\n            advance();\r\n            token = Token.EQUAL;\r\n            return token;\r\n\r\n        case 0x2D: /* '-' */\r\n            token = scanNumber();\r\n            return token;\r\n\r\n        default:\r\n            if (esutils.code.isDecimalDigit(ch)) {\r\n                token = scanNumber();\r\n                return token;\r\n            }\r\n\r\n            // type string permits following case,\r\n            //\r\n            // namespace.module.MyClass\r\n            //\r\n            // this reduced 1 token TK_NAME\r\n            utility.assert(isTypeName(ch));\r\n            token = scanTypeName();\r\n            return token;\r\n        }\r\n    }\r\n\r\n    function consume(target, text) {\r\n        utility.assert(token === target, text || 'consumed token not matched');\r\n        next();\r\n    }\r\n\r\n    function expect(target, message) {\r\n        if (token !== target) {\r\n            utility.throwError(message || 'unexpected token');\r\n        }\r\n        next();\r\n    }\r\n\r\n    // UnionType := '(' TypeUnionList ')'\r\n    //\r\n    // TypeUnionList :=\r\n    //     <<empty>>\r\n    //   | NonemptyTypeUnionList\r\n    //\r\n    // NonemptyTypeUnionList :=\r\n    //     TypeExpression\r\n    //   | TypeExpression '|' NonemptyTypeUnionList\r\n    function parseUnionType() {\r\n        var elements, startIndex = index - 1;\r\n        consume(Token.LPAREN, 'UnionType should start with (');\r\n        elements = [];\r\n        if (token !== Token.RPAREN) {\r\n            while (true) {\r\n                elements.push(parseTypeExpression());\r\n                if (token === Token.RPAREN) {\r\n                    break;\r\n                }\r\n                expect(Token.PIPE);\r\n            }\r\n        }\r\n        consume(Token.RPAREN, 'UnionType should end with )');\r\n        return maybeAddRange({\r\n            type: Syntax.UnionType,\r\n            elements: elements\r\n        }, [startIndex, previous]);\r\n    }\r\n\r\n    // ArrayType := '[' ElementTypeList ']'\r\n    //\r\n    // ElementTypeList :=\r\n    //     <<empty>>\r\n    //  | TypeExpression\r\n    //  | '...' TypeExpression\r\n    //  | TypeExpression ',' ElementTypeList\r\n    function parseArrayType() {\r\n        var elements, startIndex = index - 1, restStartIndex;\r\n        consume(Token.LBRACK, 'ArrayType should start with [');\r\n        elements = [];\r\n        while (token !== Token.RBRACK) {\r\n            if (token === Token.REST) {\r\n                restStartIndex = index - 3;\r\n                consume(Token.REST);\r\n                elements.push(maybeAddRange({\r\n                    type: Syntax.RestType,\r\n                    expression: parseTypeExpression()\r\n                }, [restStartIndex, previous]));\r\n                break;\r\n            } else {\r\n                elements.push(parseTypeExpression());\r\n            }\r\n            if (token !== Token.RBRACK) {\r\n                expect(Token.COMMA);\r\n            }\r\n        }\r\n        expect(Token.RBRACK);\r\n        return maybeAddRange({\r\n            type: Syntax.ArrayType,\r\n            elements: elements\r\n        }, [startIndex, previous]);\r\n    }\r\n\r\n    function parseFieldName() {\r\n        var v = value;\r\n        if (token === Token.NAME || token === Token.STRING) {\r\n            next();\r\n            return v;\r\n        }\r\n\r\n        if (token === Token.NUMBER) {\r\n            consume(Token.NUMBER);\r\n            return String(v);\r\n        }\r\n\r\n        utility.throwError('unexpected token');\r\n    }\r\n\r\n    // FieldType :=\r\n    //     FieldName\r\n    //   | FieldName ':' TypeExpression\r\n    //\r\n    // FieldName :=\r\n    //     NameExpression\r\n    //   | StringLiteral\r\n    //   | NumberLiteral\r\n    //   | ReservedIdentifier\r\n    function parseFieldType() {\r\n        var key, rangeStart = previous;\r\n\r\n        key = parseFieldName();\r\n        if (token === Token.COLON) {\r\n            consume(Token.COLON);\r\n            return maybeAddRange({\r\n                type: Syntax.FieldType,\r\n                key: key,\r\n                value: parseTypeExpression()\r\n            }, [rangeStart, previous]);\r\n        }\r\n        return maybeAddRange({\r\n            type: Syntax.FieldType,\r\n            key: key,\r\n            value: null\r\n        }, [rangeStart, previous]);\r\n    }\r\n\r\n    // RecordType := '{' FieldTypeList '}'\r\n    //\r\n    // FieldTypeList :=\r\n    //     <<empty>>\r\n    //   | FieldType\r\n    //   | FieldType ',' FieldTypeList\r\n    function parseRecordType() {\r\n        var fields, rangeStart = index - 1, rangeEnd;\r\n\r\n        consume(Token.LBRACE, 'RecordType should start with {');\r\n        fields = [];\r\n        if (token === Token.COMMA) {\r\n            consume(Token.COMMA);\r\n        } else {\r\n            while (token !== Token.RBRACE) {\r\n                fields.push(parseFieldType());\r\n                if (token !== Token.RBRACE) {\r\n                    expect(Token.COMMA);\r\n                }\r\n            }\r\n        }\r\n        rangeEnd = index;\r\n        expect(Token.RBRACE);\r\n        return maybeAddRange({\r\n            type: Syntax.RecordType,\r\n            fields: fields\r\n        }, [rangeStart, rangeEnd]);\r\n    }\r\n\r\n    // NameExpression :=\r\n    //    Identifier\r\n    //  | TagIdentifier ':' Identifier\r\n    //\r\n    // Tag identifier is one of \"module\", \"external\" or \"event\"\r\n    // Identifier is the same as Token.NAME, including any dots, something like\r\n    // namespace.module.MyClass\r\n    function parseNameExpression() {\r\n        var name = value, rangeStart = index - name.length;\r\n        expect(Token.NAME);\r\n\r\n        if (token === Token.COLON && (\r\n                name === 'module' ||\r\n                name === 'external' ||\r\n                name === 'event')) {\r\n            consume(Token.COLON);\r\n            name += ':' + value;\r\n            expect(Token.NAME);\r\n        }\r\n\r\n        return maybeAddRange({\r\n            type: Syntax.NameExpression,\r\n            name: name\r\n        }, [rangeStart, previous]);\r\n    }\r\n\r\n    // TypeExpressionList :=\r\n    //     TopLevelTypeExpression\r\n    //   | TopLevelTypeExpression ',' TypeExpressionList\r\n    function parseTypeExpressionList() {\r\n        var elements = [];\r\n\r\n        elements.push(parseTop());\r\n        while (token === Token.COMMA) {\r\n            consume(Token.COMMA);\r\n            elements.push(parseTop());\r\n        }\r\n        return elements;\r\n    }\r\n\r\n    // TypeName :=\r\n    //     NameExpression\r\n    //   | NameExpression TypeApplication\r\n    //\r\n    // TypeApplication :=\r\n    //     '.<' TypeExpressionList '>'\r\n    //   | '<' TypeExpressionList '>'   // this is extension of doctrine\r\n    function parseTypeName() {\r\n        var expr, applications, startIndex = index - value.length;\r\n\r\n        expr = parseNameExpression();\r\n        if (token === Token.DOT_LT || token === Token.LT) {\r\n            next();\r\n            applications = parseTypeExpressionList();\r\n            expect(Token.GT);\r\n            return maybeAddRange({\r\n                type: Syntax.TypeApplication,\r\n                expression: expr,\r\n                applications: applications\r\n            }, [startIndex, previous]);\r\n        }\r\n        return expr;\r\n    }\r\n\r\n    // ResultType :=\r\n    //     <<empty>>\r\n    //   | ':' void\r\n    //   | ':' TypeExpression\r\n    //\r\n    // BNF is above\r\n    // but, we remove <<empty>> pattern, so token is always TypeToken::COLON\r\n    function parseResultType() {\r\n        consume(Token.COLON, 'ResultType should start with :');\r\n        if (token === Token.NAME && value === 'void') {\r\n            consume(Token.NAME);\r\n            return {\r\n                type: Syntax.VoidLiteral\r\n            };\r\n        }\r\n        return parseTypeExpression();\r\n    }\r\n\r\n    // ParametersType :=\r\n    //     RestParameterType\r\n    //   | NonRestParametersType\r\n    //   | NonRestParametersType ',' RestParameterType\r\n    //\r\n    // RestParameterType :=\r\n    //     '...'\r\n    //     '...' Identifier\r\n    //\r\n    // NonRestParametersType :=\r\n    //     ParameterType ',' NonRestParametersType\r\n    //   | ParameterType\r\n    //   | OptionalParametersType\r\n    //\r\n    // OptionalParametersType :=\r\n    //     OptionalParameterType\r\n    //   | OptionalParameterType, OptionalParametersType\r\n    //\r\n    // OptionalParameterType := ParameterType=\r\n    //\r\n    // ParameterType := TypeExpression | Identifier ':' TypeExpression\r\n    //\r\n    // Identifier is \"new\" or \"this\"\r\n    function parseParametersType() {\r\n        var params = [], optionalSequence = false, expr, rest = false, startIndex, restStartIndex = index - 3, nameStartIndex;\r\n\r\n        while (token !== Token.RPAREN) {\r\n            if (token === Token.REST) {\r\n                // RestParameterType\r\n                consume(Token.REST);\r\n                rest = true;\r\n            }\r\n\r\n            startIndex = previous;\r\n\r\n            expr = parseTypeExpression();\r\n            if (expr.type === Syntax.NameExpression && token === Token.COLON) {\r\n                nameStartIndex = previous - expr.name.length;\r\n                // Identifier ':' TypeExpression\r\n                consume(Token.COLON);\r\n                expr = maybeAddRange({\r\n                    type: Syntax.ParameterType,\r\n                    name: expr.name,\r\n                    expression: parseTypeExpression()\r\n                }, [nameStartIndex, previous]);\r\n            }\r\n            if (token === Token.EQUAL) {\r\n                consume(Token.EQUAL);\r\n                expr = maybeAddRange({\r\n                    type: Syntax.OptionalType,\r\n                    expression: expr\r\n                }, [startIndex, previous]);\r\n                optionalSequence = true;\r\n            } else {\r\n                if (optionalSequence) {\r\n                    utility.throwError('unexpected token');\r\n                }\r\n            }\r\n            if (rest) {\r\n                expr = maybeAddRange({\r\n                    type: Syntax.RestType,\r\n                    expression: expr\r\n                }, [restStartIndex, previous]);\r\n            }\r\n            params.push(expr);\r\n            if (token !== Token.RPAREN) {\r\n                expect(Token.COMMA);\r\n            }\r\n        }\r\n        return params;\r\n    }\r\n\r\n    // FunctionType := 'function' FunctionSignatureType\r\n    //\r\n    // FunctionSignatureType :=\r\n    //   | TypeParameters '(' ')' ResultType\r\n    //   | TypeParameters '(' ParametersType ')' ResultType\r\n    //   | TypeParameters '(' 'this' ':' TypeName ')' ResultType\r\n    //   | TypeParameters '(' 'this' ':' TypeName ',' ParametersType ')' ResultType\r\n    function parseFunctionType() {\r\n        var isNew, thisBinding, params, result, fnType, startIndex = index - value.length;\r\n        utility.assert(token === Token.NAME && value === 'function', 'FunctionType should start with \\'function\\'');\r\n        consume(Token.NAME);\r\n\r\n        // Google Closure Compiler is not implementing TypeParameters.\r\n        // So we do not. if we don't get '(', we see it as error.\r\n        expect(Token.LPAREN);\r\n\r\n        isNew = false;\r\n        params = [];\r\n        thisBinding = null;\r\n        if (token !== Token.RPAREN) {\r\n            // ParametersType or 'this'\r\n            if (token === Token.NAME &&\r\n                    (value === 'this' || value === 'new')) {\r\n                // 'this' or 'new'\r\n                // 'new' is Closure Compiler extension\r\n                isNew = value === 'new';\r\n                consume(Token.NAME);\r\n                expect(Token.COLON);\r\n                thisBinding = parseTypeName();\r\n                if (token === Token.COMMA) {\r\n                    consume(Token.COMMA);\r\n                    params = parseParametersType();\r\n                }\r\n            } else {\r\n                params = parseParametersType();\r\n            }\r\n        }\r\n\r\n        expect(Token.RPAREN);\r\n\r\n        result = null;\r\n        if (token === Token.COLON) {\r\n            result = parseResultType();\r\n        }\r\n\r\n        fnType = maybeAddRange({\r\n            type: Syntax.FunctionType,\r\n            params: params,\r\n            result: result\r\n        }, [startIndex, previous]);\r\n        if (thisBinding) {\r\n            // avoid adding null 'new' and 'this' properties\r\n            fnType['this'] = thisBinding;\r\n            if (isNew) {\r\n                fnType['new'] = true;\r\n            }\r\n        }\r\n        return fnType;\r\n    }\r\n\r\n    // BasicTypeExpression :=\r\n    //     '*'\r\n    //   | 'null'\r\n    //   | 'undefined'\r\n    //   | TypeName\r\n    //   | FunctionType\r\n    //   | UnionType\r\n    //   | RecordType\r\n    //   | ArrayType\r\n    function parseBasicTypeExpression() {\r\n        var context, startIndex;\r\n        switch (token) {\r\n        case Token.STAR:\r\n            consume(Token.STAR);\r\n            return maybeAddRange({\r\n                type: Syntax.AllLiteral\r\n            }, [previous - 1, previous]);\r\n\r\n        case Token.LPAREN:\r\n            return parseUnionType();\r\n\r\n        case Token.LBRACK:\r\n            return parseArrayType();\r\n\r\n        case Token.LBRACE:\r\n            return parseRecordType();\r\n\r\n        case Token.NAME:\r\n            startIndex = index - value.length;\r\n\r\n            if (value === 'null') {\r\n                consume(Token.NAME);\r\n                return maybeAddRange({\r\n                    type: Syntax.NullLiteral\r\n                }, [startIndex, previous]);\r\n            }\r\n\r\n            if (value === 'undefined') {\r\n                consume(Token.NAME);\r\n                return maybeAddRange({\r\n                    type: Syntax.UndefinedLiteral\r\n                }, [startIndex, previous]);\r\n            }\r\n\r\n            if (value === 'true' || value === 'false') {\r\n                consume(Token.NAME);\r\n                return maybeAddRange({\r\n                    type: Syntax.BooleanLiteralType,\r\n                    value: value === 'true'\r\n                }, [startIndex, previous]);\r\n            }\r\n\r\n            context = Context.save();\r\n            if (value === 'function') {\r\n                try {\r\n                    return parseFunctionType();\r\n                } catch (e) {\r\n                    context.restore();\r\n                }\r\n            }\r\n\r\n            return parseTypeName();\r\n\r\n        case Token.STRING:\r\n            next();\r\n            return maybeAddRange({\r\n                type: Syntax.StringLiteralType,\r\n                value: value\r\n            }, [previous - value.length - 2, previous]);\r\n\r\n        case Token.NUMBER:\r\n            next();\r\n            return maybeAddRange({\r\n                type: Syntax.NumericLiteralType,\r\n                value: value\r\n            }, [previous - String(value).length, previous]);\r\n\r\n        default:\r\n            utility.throwError('unexpected token');\r\n        }\r\n    }\r\n\r\n    // TypeExpression :=\r\n    //     BasicTypeExpression\r\n    //   | '?' BasicTypeExpression\r\n    //   | '!' BasicTypeExpression\r\n    //   | BasicTypeExpression '?'\r\n    //   | BasicTypeExpression '!'\r\n    //   | '?'\r\n    //   | BasicTypeExpression '[]'\r\n    function parseTypeExpression() {\r\n        var expr, rangeStart;\r\n\r\n        if (token === Token.QUESTION) {\r\n            rangeStart = index - 1;\r\n            consume(Token.QUESTION);\r\n            if (token === Token.COMMA || token === Token.EQUAL || token === Token.RBRACE ||\r\n                    token === Token.RPAREN || token === Token.PIPE || token === Token.EOF ||\r\n                    token === Token.RBRACK || token === Token.GT) {\r\n                return maybeAddRange({\r\n                    type: Syntax.NullableLiteral\r\n                }, [rangeStart, previous]);\r\n            }\r\n            return maybeAddRange({\r\n                type: Syntax.NullableType,\r\n                expression: parseBasicTypeExpression(),\r\n                prefix: true\r\n            }, [rangeStart, previous]);\r\n        } else if (token === Token.BANG) {\r\n            rangeStart = index - 1;\r\n            consume(Token.BANG);\r\n            return maybeAddRange({\r\n                type: Syntax.NonNullableType,\r\n                expression: parseBasicTypeExpression(),\r\n                prefix: true\r\n            }, [rangeStart, previous]);\r\n        } else {\r\n            rangeStart = previous;\r\n        }\r\n\r\n        expr = parseBasicTypeExpression();\r\n        if (token === Token.BANG) {\r\n            consume(Token.BANG);\r\n            return maybeAddRange({\r\n                type: Syntax.NonNullableType,\r\n                expression: expr,\r\n                prefix: false\r\n            }, [rangeStart, previous]);\r\n        }\r\n\r\n        if (token === Token.QUESTION) {\r\n            consume(Token.QUESTION);\r\n            return maybeAddRange({\r\n                type: Syntax.NullableType,\r\n                expression: expr,\r\n                prefix: false\r\n            }, [rangeStart, previous]);\r\n        }\r\n\r\n        if (token === Token.LBRACK) {\r\n            consume(Token.LBRACK);\r\n            expect(Token.RBRACK, 'expected an array-style type declaration (' + value + '[])');\r\n            return maybeAddRange({\r\n                type: Syntax.TypeApplication,\r\n                expression: maybeAddRange({\r\n                    type: Syntax.NameExpression,\r\n                    name: 'Array'\r\n                }, [rangeStart, previous]),\r\n                applications: [expr]\r\n            }, [rangeStart, previous]);\r\n        }\r\n\r\n        return expr;\r\n    }\r\n\r\n    // TopLevelTypeExpression :=\r\n    //      TypeExpression\r\n    //    | TypeUnionList\r\n    //\r\n    // This rule is Google Closure Compiler extension, not ES4\r\n    // like,\r\n    //   { number | string }\r\n    // If strict to ES4, we should write it as\r\n    //   { (number|string) }\r\n    function parseTop() {\r\n        var expr, elements;\r\n\r\n        expr = parseTypeExpression();\r\n        if (token !== Token.PIPE) {\r\n            return expr;\r\n        }\r\n\r\n        elements = [expr];\r\n        consume(Token.PIPE);\r\n        while (true) {\r\n            elements.push(parseTypeExpression());\r\n            if (token !== Token.PIPE) {\r\n                break;\r\n            }\r\n            consume(Token.PIPE);\r\n        }\r\n\r\n        return maybeAddRange({\r\n            type: Syntax.UnionType,\r\n            elements: elements\r\n        }, [0, index]);\r\n    }\r\n\r\n    function parseTopParamType() {\r\n        var expr;\r\n\r\n        if (token === Token.REST) {\r\n            consume(Token.REST);\r\n            return maybeAddRange({\r\n                type: Syntax.RestType,\r\n                expression: parseTop()\r\n            }, [0, index]);\r\n        }\r\n\r\n        expr = parseTop();\r\n        if (token === Token.EQUAL) {\r\n            consume(Token.EQUAL);\r\n            return maybeAddRange({\r\n                type: Syntax.OptionalType,\r\n                expression: expr\r\n            }, [0, index]);\r\n        }\r\n\r\n        return expr;\r\n    }\r\n\r\n    function parseType(src, opt) {\r\n        var expr;\r\n\r\n        source = src;\r\n        length = source.length;\r\n        index = 0;\r\n        previous = 0;\r\n        addRange = opt && opt.range;\r\n        rangeOffset = opt && opt.startIndex || 0;\r\n\r\n        next();\r\n        expr = parseTop();\r\n\r\n        if (opt && opt.midstream) {\r\n            return {\r\n                expression: expr,\r\n                index: previous\r\n            };\r\n        }\r\n\r\n        if (token !== Token.EOF) {\r\n            utility.throwError('not reach to EOF');\r\n        }\r\n\r\n        return expr;\r\n    }\r\n\r\n    function parseParamType(src, opt) {\r\n        var expr;\r\n\r\n        source = src;\r\n        length = source.length;\r\n        index = 0;\r\n        previous = 0;\r\n        addRange = opt && opt.range;\r\n        rangeOffset = opt && opt.startIndex || 0;\r\n\r\n        next();\r\n        expr = parseTopParamType();\r\n\r\n        if (opt && opt.midstream) {\r\n            return {\r\n                expression: expr,\r\n                index: previous\r\n            };\r\n        }\r\n\r\n        if (token !== Token.EOF) {\r\n            utility.throwError('not reach to EOF');\r\n        }\r\n\r\n        return expr;\r\n    }\r\n\r\n    function stringifyImpl(node, compact, topLevel) {\r\n        var result, i, iz;\r\n\r\n        switch (node.type) {\r\n        case Syntax.NullableLiteral:\r\n            result = '?';\r\n            break;\r\n\r\n        case Syntax.AllLiteral:\r\n            result = '*';\r\n            break;\r\n\r\n        case Syntax.NullLiteral:\r\n            result = 'null';\r\n            break;\r\n\r\n        case Syntax.UndefinedLiteral:\r\n            result = 'undefined';\r\n            break;\r\n\r\n        case Syntax.VoidLiteral:\r\n            result = 'void';\r\n            break;\r\n\r\n        case Syntax.UnionType:\r\n            if (!topLevel) {\r\n                result = '(';\r\n            } else {\r\n                result = '';\r\n            }\r\n\r\n            for (i = 0, iz = node.elements.length; i < iz; ++i) {\r\n                result += stringifyImpl(node.elements[i], compact);\r\n                if ((i + 1) !== iz) {\r\n                    result += compact ? '|' : ' | ';\r\n                }\r\n            }\r\n\r\n            if (!topLevel) {\r\n                result += ')';\r\n            }\r\n            break;\r\n\r\n        case Syntax.ArrayType:\r\n            result = '[';\r\n            for (i = 0, iz = node.elements.length; i < iz; ++i) {\r\n                result += stringifyImpl(node.elements[i], compact);\r\n                if ((i + 1) !== iz) {\r\n                    result += compact ? ',' : ', ';\r\n                }\r\n            }\r\n            result += ']';\r\n            break;\r\n\r\n        case Syntax.RecordType:\r\n            result = '{';\r\n            for (i = 0, iz = node.fields.length; i < iz; ++i) {\r\n                result += stringifyImpl(node.fields[i], compact);\r\n                if ((i + 1) !== iz) {\r\n                    result += compact ? ',' : ', ';\r\n                }\r\n            }\r\n            result += '}';\r\n            break;\r\n\r\n        case Syntax.FieldType:\r\n            if (node.value) {\r\n                result = node.key + (compact ? ':' : ': ') + stringifyImpl(node.value, compact);\r\n            } else {\r\n                result = node.key;\r\n            }\r\n            break;\r\n\r\n        case Syntax.FunctionType:\r\n            result = compact ? 'function(' : 'function (';\r\n\r\n            if (node['this']) {\r\n                if (node['new']) {\r\n                    result += (compact ? 'new:' : 'new: ');\r\n                } else {\r\n                    result += (compact ? 'this:' : 'this: ');\r\n                }\r\n\r\n                result += stringifyImpl(node['this'], compact);\r\n\r\n                if (node.params.length !== 0) {\r\n                    result += compact ? ',' : ', ';\r\n                }\r\n            }\r\n\r\n            for (i = 0, iz = node.params.length; i < iz; ++i) {\r\n                result += stringifyImpl(node.params[i], compact);\r\n                if ((i + 1) !== iz) {\r\n                    result += compact ? ',' : ', ';\r\n                }\r\n            }\r\n\r\n            result += ')';\r\n\r\n            if (node.result) {\r\n                result += (compact ? ':' : ': ') + stringifyImpl(node.result, compact);\r\n            }\r\n            break;\r\n\r\n        case Syntax.ParameterType:\r\n            result = node.name + (compact ? ':' : ': ') + stringifyImpl(node.expression, compact);\r\n            break;\r\n\r\n        case Syntax.RestType:\r\n            result = '...';\r\n            if (node.expression) {\r\n                result += stringifyImpl(node.expression, compact);\r\n            }\r\n            break;\r\n\r\n        case Syntax.NonNullableType:\r\n            if (node.prefix) {\r\n                result = '!' + stringifyImpl(node.expression, compact);\r\n            } else {\r\n                result = stringifyImpl(node.expression, compact) + '!';\r\n            }\r\n            break;\r\n\r\n        case Syntax.OptionalType:\r\n            result = stringifyImpl(node.expression, compact) + '=';\r\n            break;\r\n\r\n        case Syntax.NullableType:\r\n            if (node.prefix) {\r\n                result = '?' + stringifyImpl(node.expression, compact);\r\n            } else {\r\n                result = stringifyImpl(node.expression, compact) + '?';\r\n            }\r\n            break;\r\n\r\n        case Syntax.NameExpression:\r\n            result = node.name;\r\n            break;\r\n\r\n        case Syntax.TypeApplication:\r\n            result = stringifyImpl(node.expression, compact) + '.<';\r\n            for (i = 0, iz = node.applications.length; i < iz; ++i) {\r\n                result += stringifyImpl(node.applications[i], compact);\r\n                if ((i + 1) !== iz) {\r\n                    result += compact ? ',' : ', ';\r\n                }\r\n            }\r\n            result += '>';\r\n            break;\r\n\r\n        case Syntax.StringLiteralType:\r\n            result = '\"' + node.value + '\"';\r\n            break;\r\n\r\n        case Syntax.NumericLiteralType:\r\n            result = String(node.value);\r\n            break;\r\n\r\n        case Syntax.BooleanLiteralType:\r\n            result = String(node.value);\r\n            break;\r\n\r\n        default:\r\n            utility.throwError('Unknown type ' + node.type);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function stringify(node, options) {\r\n        if (options == null) {\r\n            options = {};\r\n        }\r\n        return stringifyImpl(node, options.compact, options.topLevel);\r\n    }\r\n\r\n    exports.parseType = parseType;\r\n    exports.parseParamType = parseParamType;\r\n    exports.stringify = stringify;\r\n    exports.Syntax = Syntax;\r\n}());\r\n/* vim: set sw=4 ts=4 et tw=80 : */\r\n", "/*\r\n * @fileoverview Main Doctrine object\r\n * @author Yusuke Suzuki <utatane.tea@gmail.com>\r\n * @author Dan Tao <daniel.tao@gmail.com>\r\n * @author Andrew Eisenberg <andrew@eisenberg.as>\r\n */\r\n\r\n(function () {\r\n    'use strict';\r\n\r\n    var typed,\r\n        utility,\r\n        jsdoc,\r\n        esutils,\r\n        hasOwnProperty;\r\n\r\n    esutils = require('esutils');\r\n    typed = require('./typed');\r\n    utility = require('./utility');\r\n\r\n    function sliceSource(source, index, last) {\r\n        return source.slice(index, last);\r\n    }\r\n\r\n    hasOwnProperty = (function () {\r\n        var func = Object.prototype.hasOwnProperty;\r\n        return function hasOwnProperty(obj, name) {\r\n            return func.call(obj, name);\r\n        };\r\n    }());\r\n    function shallowCopy(obj) {\r\n        var ret = {}, key;\r\n        for (key in obj) {\r\n            if (obj.hasOwnProperty(key)) {\r\n                ret[key] = obj[key];\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    function isASCIIAlphanumeric(ch) {\r\n        return (ch >= 0x61  /* 'a' */ && ch <= 0x7A  /* 'z' */) ||\r\n            (ch >= 0x41  /* 'A' */ && ch <= 0x5A  /* 'Z' */) ||\r\n            (ch >= 0x30  /* '0' */ && ch <= 0x39  /* '9' */);\r\n    }\r\n\r\n    function isParamTitle(title) {\r\n        return title === 'param' || title === 'argument' || title === 'arg';\r\n    }\r\n\r\n    function isReturnTitle(title) {\r\n        return title === 'return' || title === 'returns';\r\n    }\r\n\r\n    function isProperty(title) {\r\n        return title === 'property' || title === 'prop';\r\n    }\r\n\r\n    function isNameParameterRequired(title) {\r\n        return isParamTitle(title) || isProperty(title) ||\r\n            title === 'alias' || title === 'this' || title === 'mixes' || title === 'requires';\r\n    }\r\n\r\n    function isAllowedName(title) {\r\n        return isNameParameterRequired(title) || title === 'const' || title === 'constant';\r\n    }\r\n\r\n    function isAllowedNested(title) {\r\n        return isProperty(title) || isParamTitle(title);\r\n    }\r\n\r\n    function isAllowedOptional(title) {\r\n        return isProperty(title) || isParamTitle(title);\r\n    }\r\n\r\n    function isTypeParameterRequired(title) {\r\n        return isParamTitle(title) || isReturnTitle(title) ||\r\n            title === 'define' || title === 'enum' ||\r\n            title === 'implements' || title === 'this' ||\r\n            title === 'type' || title === 'typedef' || isProperty(title);\r\n    }\r\n\r\n    // Consider deprecation instead using 'isTypeParameterRequired' and 'Rules' declaration to pick when a type is optional/required\r\n    // This would require changes to 'parseType'\r\n    function isAllowedType(title) {\r\n        return isTypeParameterRequired(title) || title === 'throws' || title === 'const' || title === 'constant' ||\r\n            title === 'namespace' || title === 'member' || title === 'var' || title === 'module' ||\r\n            title === 'constructor' || title === 'class' || title === 'extends' || title === 'augments' ||\r\n            title === 'public' || title === 'private' || title === 'protected';\r\n    }\r\n\r\n    // A regex character class that contains all whitespace except linebreak characters (\\r, \\n, \\u2028, \\u2029)\r\n    var WHITESPACE = '[ \\\\f\\\\t\\\\v\\\\u00a0\\\\u1680\\\\u180e\\\\u2000-\\\\u200a\\\\u202f\\\\u205f\\\\u3000\\\\ufeff]';\r\n\r\n    var STAR_MATCHER = '(' + WHITESPACE + '*(?:\\\\*' + WHITESPACE + '?)?)(.+|[\\r\\n\\u2028\\u2029])';\r\n\r\n    function unwrapComment(doc) {\r\n        // JSDoc comment is following form\r\n        //   /**\r\n        //    * .......\r\n        //    */\r\n\r\n        return doc.\r\n            // remove /**\r\n            replace(/^\\/\\*\\*?/, '').\r\n            // remove */\r\n            replace(/\\*\\/$/, '').\r\n            // remove ' * ' at the beginning of a line\r\n            replace(new RegExp(STAR_MATCHER, 'g'), '$2').\r\n            // remove trailing whitespace\r\n            replace(/\\s*$/, '');\r\n    }\r\n\r\n    /**\r\n     * Converts an index in an \"unwrapped\" JSDoc comment to the corresponding index in the original \"wrapped\" version\r\n     * @param {string} originalSource The original wrapped comment\r\n     * @param {number} unwrappedIndex The index of a character in the unwrapped string\r\n     * @returns {number} The index of the corresponding character in the original wrapped string\r\n     */\r\n    function convertUnwrappedCommentIndex(originalSource, unwrappedIndex) {\r\n        var replacedSource = originalSource.replace(/^\\/\\*\\*?/, '');\r\n        var numSkippedChars = 0;\r\n        var matcher = new RegExp(STAR_MATCHER, 'g');\r\n        var match;\r\n\r\n        while ((match = matcher.exec(replacedSource))) {\r\n            numSkippedChars += match[1].length;\r\n\r\n            if (match.index + match[0].length > unwrappedIndex + numSkippedChars) {\r\n                return unwrappedIndex + numSkippedChars + originalSource.length - replacedSource.length;\r\n            }\r\n        }\r\n\r\n        return originalSource.replace(/\\*\\/$/, '').replace(/\\s*$/, '').length;\r\n    }\r\n\r\n    // JSDoc Tag Parser\r\n\r\n    (function (exports) {\r\n        var Rules,\r\n            index,\r\n            lineNumber,\r\n            length,\r\n            source,\r\n            originalSource,\r\n            recoverable,\r\n            sloppy,\r\n            strict;\r\n\r\n        function advance() {\r\n            var ch = source.charCodeAt(index);\r\n            index += 1;\r\n            if (esutils.code.isLineTerminator(ch) && !(ch === 0x0D  /* '\\r' */ && source.charCodeAt(index) === 0x0A  /* '\\n' */)) {\r\n                lineNumber += 1;\r\n            }\r\n            return String.fromCharCode(ch);\r\n        }\r\n\r\n        function scanTitle() {\r\n            var title = '';\r\n            // waste '@'\r\n            advance();\r\n\r\n            while (index < length && isASCIIAlphanumeric(source.charCodeAt(index))) {\r\n                title += advance();\r\n            }\r\n\r\n            return title;\r\n        }\r\n\r\n        function seekContent() {\r\n            var ch, waiting, last = index;\r\n\r\n            waiting = false;\r\n            while (last < length) {\r\n                ch = source.charCodeAt(last);\r\n                if (esutils.code.isLineTerminator(ch) && !(ch === 0x0D  /* '\\r' */ && source.charCodeAt(last + 1) === 0x0A  /* '\\n' */)) {\r\n                    waiting = true;\r\n                } else if (waiting) {\r\n                    if (ch === 0x40  /* '@' */) {\r\n                        break;\r\n                    }\r\n                    if (!esutils.code.isWhiteSpace(ch)) {\r\n                        waiting = false;\r\n                    }\r\n                }\r\n                last += 1;\r\n            }\r\n            return last;\r\n        }\r\n\r\n        // type expression may have nest brace, such as,\r\n        // { { ok: string } }\r\n        //\r\n        // therefore, scanning type expression with balancing braces.\r\n        function parseType(title, last, addRange) {\r\n            var ch, brace, type, startIndex, direct = false;\r\n\r\n\r\n            // search '{'\r\n            while (index < last) {\r\n                ch = source.charCodeAt(index);\r\n                if (esutils.code.isWhiteSpace(ch)) {\r\n                    advance();\r\n                } else if (ch === 0x7B  /* '{' */) {\r\n                    advance();\r\n                    break;\r\n                } else {\r\n                    // this is direct pattern\r\n                    direct = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n\r\n            if (direct) {\r\n                return null;\r\n            }\r\n\r\n            // type expression { is found\r\n            brace = 1;\r\n            type = '';\r\n            while (index < last) {\r\n                ch = source.charCodeAt(index);\r\n                if (esutils.code.isLineTerminator(ch)) {\r\n                    advance();\r\n                } else {\r\n                    if (ch === 0x7D  /* '}' */) {\r\n                        brace -= 1;\r\n                        if (brace === 0) {\r\n                            advance();\r\n                            break;\r\n                        }\r\n                    } else if (ch === 0x7B  /* '{' */) {\r\n                        brace += 1;\r\n                    }\r\n                    if (type === '') {\r\n                        startIndex = index;\r\n                    }\r\n                    type += advance();\r\n                }\r\n            }\r\n\r\n            if (brace !== 0) {\r\n                // braces is not balanced\r\n                return utility.throwError('Braces are not balanced');\r\n            }\r\n\r\n            if (isAllowedOptional(title)) {\r\n                return typed.parseParamType(type, {startIndex: convertIndex(startIndex), range: addRange});\r\n            }\r\n\r\n            return typed.parseType(type, {startIndex: convertIndex(startIndex), range: addRange});\r\n        }\r\n\r\n        function scanIdentifier(last) {\r\n            var identifier;\r\n            if (!esutils.code.isIdentifierStartES5(source.charCodeAt(index)) && !source[index].match(/[0-9]/)) {\r\n                return null;\r\n            }\r\n            identifier = advance();\r\n            while (index < last && esutils.code.isIdentifierPartES5(source.charCodeAt(index))) {\r\n                identifier += advance();\r\n            }\r\n            return identifier;\r\n        }\r\n\r\n        function skipWhiteSpace(last) {\r\n            while (index < last && (esutils.code.isWhiteSpace(source.charCodeAt(index)) || esutils.code.isLineTerminator(source.charCodeAt(index)))) {\r\n                advance();\r\n            }\r\n        }\r\n\r\n        function parseName(last, allowBrackets, allowNestedParams) {\r\n            var name = '',\r\n                useBrackets,\r\n                insideString;\r\n\r\n\r\n            skipWhiteSpace(last);\r\n\r\n            if (index >= last) {\r\n                return null;\r\n            }\r\n\r\n            if (source.charCodeAt(index) === 0x5B  /* '[' */) {\r\n                if (allowBrackets) {\r\n                    useBrackets = true;\r\n                    name = advance();\r\n                } else {\r\n                    return null;\r\n                }\r\n            }\r\n\r\n            name += scanIdentifier(last);\r\n\r\n            if (allowNestedParams) {\r\n                if (source.charCodeAt(index) === 0x3A /* ':' */ && (\r\n                        name === 'module' ||\r\n                        name === 'external' ||\r\n                        name === 'event')) {\r\n                    name += advance();\r\n                    name += scanIdentifier(last);\r\n\r\n                }\r\n                if(source.charCodeAt(index) === 0x5B  /* '[' */ && source.charCodeAt(index + 1) === 0x5D  /* ']' */){\r\n                    name += advance();\r\n                    name += advance();\r\n                }\r\n                while (source.charCodeAt(index) === 0x2E  /* '.' */ ||\r\n                        source.charCodeAt(index) === 0x2F  /* '/' */ ||\r\n                        source.charCodeAt(index) === 0x23  /* '#' */ ||\r\n                        source.charCodeAt(index) === 0x2D  /* '-' */ ||\r\n                        source.charCodeAt(index) === 0x7E  /* '~' */) {\r\n                    name += advance();\r\n                    name += scanIdentifier(last);\r\n                }\r\n            }\r\n\r\n            if (useBrackets) {\r\n                skipWhiteSpace(last);\r\n                // do we have a default value for this?\r\n                if (source.charCodeAt(index) === 0x3D  /* '=' */) {\r\n                    // consume the '='' symbol\r\n                    name += advance();\r\n                    skipWhiteSpace(last);\r\n\r\n                    var ch;\r\n                    var bracketDepth = 1;\r\n\r\n                    // scan in the default value\r\n                    while (index < last) {\r\n                        ch = source.charCodeAt(index);\r\n\r\n                        if (esutils.code.isWhiteSpace(ch)) {\r\n                            if (!insideString) {\r\n                                skipWhiteSpace(last);\r\n                                ch = source.charCodeAt(index);\r\n                            }\r\n                        }\r\n\r\n                        if (ch === 0x27 /* ''' */) {\r\n                            if (!insideString) {\r\n                                insideString = '\\'';\r\n                            } else {\r\n                                if (insideString === '\\'') {\r\n                                    insideString = '';\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        if (ch === 0x22 /* '\"' */) {\r\n                            if (!insideString) {\r\n                                insideString = '\"';\r\n                            } else {\r\n                                if (insideString === '\"') {\r\n                                    insideString = '';\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        if (ch === 0x5B /* '[' */) {\r\n                            bracketDepth++;\r\n                        } else if (ch === 0x5D  /* ']' */ &&\r\n                            --bracketDepth === 0) {\r\n                            break;\r\n                        }\r\n\r\n                        name += advance();\r\n                    }\r\n                }\r\n\r\n                skipWhiteSpace(last);\r\n\r\n                if (index >= last || source.charCodeAt(index) !== 0x5D  /* ']' */) {\r\n                    // we never found a closing ']'\r\n                    return null;\r\n                }\r\n\r\n                // collect the last ']'\r\n                name += advance();\r\n            }\r\n\r\n            return name;\r\n        }\r\n\r\n        function skipToTag() {\r\n            while (index < length && source.charCodeAt(index) !== 0x40  /* '@' */) {\r\n                advance();\r\n            }\r\n            if (index >= length) {\r\n                return false;\r\n            }\r\n            utility.assert(source.charCodeAt(index) === 0x40  /* '@' */);\r\n            return true;\r\n        }\r\n\r\n        function convertIndex(rangeIndex) {\r\n            if (source === originalSource) {\r\n                return rangeIndex;\r\n            }\r\n            return convertUnwrappedCommentIndex(originalSource, rangeIndex);\r\n        }\r\n\r\n        function TagParser(options, title) {\r\n            this._options = options;\r\n            this._title = title.toLowerCase();\r\n            this._tag = {\r\n                title: title,\r\n                description: null\r\n            };\r\n            if (this._options.lineNumbers) {\r\n                this._tag.lineNumber = lineNumber;\r\n            }\r\n            this._first = index - title.length - 1;\r\n            this._last = 0;\r\n            // space to save special information for title parsers.\r\n            this._extra = { };\r\n        }\r\n\r\n        // addError(err, ...)\r\n        TagParser.prototype.addError = function addError(errorText) {\r\n            var args = Array.prototype.slice.call(arguments, 1),\r\n                msg = errorText.replace(\r\n                    /%(\\d)/g,\r\n                    function (whole, index) {\r\n                        utility.assert(index < args.length, 'Message reference must be in range');\r\n                        return args[index];\r\n                    }\r\n                );\r\n\r\n            if (!this._tag.errors) {\r\n                this._tag.errors = [];\r\n            }\r\n            if (strict) {\r\n                utility.throwError(msg);\r\n            }\r\n            this._tag.errors.push(msg);\r\n            return recoverable;\r\n        };\r\n\r\n        TagParser.prototype.parseType = function () {\r\n            // type required titles\r\n            if (isTypeParameterRequired(this._title)) {\r\n                try {\r\n                    this._tag.type = parseType(this._title, this._last, this._options.range);\r\n                    if (!this._tag.type) {\r\n                        if (!isParamTitle(this._title) && !isReturnTitle(this._title)) {\r\n                            if (!this.addError('Missing or invalid tag type')) {\r\n                                return false;\r\n                            }\r\n                        }\r\n                    }\r\n                } catch (error) {\r\n                    this._tag.type = null;\r\n                    if (!this.addError(error.message)) {\r\n                        return false;\r\n                    }\r\n                }\r\n            } else if (isAllowedType(this._title)) {\r\n                // optional types\r\n                try {\r\n                    this._tag.type = parseType(this._title, this._last, this._options.range);\r\n                } catch (e) {\r\n                    //For optional types, lets drop the thrown error when we hit the end of the file\r\n                }\r\n            }\r\n            return true;\r\n        };\r\n\r\n        TagParser.prototype._parseNamePath = function (optional) {\r\n            var name;\r\n            name = parseName(this._last, sloppy && isAllowedOptional(this._title), true);\r\n            if (!name) {\r\n                if (!optional) {\r\n                    if (!this.addError('Missing or invalid tag name')) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n            this._tag.name = name;\r\n            return true;\r\n        };\r\n\r\n        TagParser.prototype.parseNamePath = function () {\r\n            return this._parseNamePath(false);\r\n        };\r\n\r\n        TagParser.prototype.parseNamePathOptional = function () {\r\n            return this._parseNamePath(true);\r\n        };\r\n\r\n\r\n        TagParser.prototype.parseName = function () {\r\n            var assign, name;\r\n\r\n            // param, property requires name\r\n            if (isAllowedName(this._title)) {\r\n                this._tag.name = parseName(this._last, sloppy && isAllowedOptional(this._title), isAllowedNested(this._title));\r\n                if (!this._tag.name) {\r\n                    if (!isNameParameterRequired(this._title)) {\r\n                        return true;\r\n                    }\r\n\r\n                    // it's possible the name has already been parsed but interpreted as a type\r\n                    // it's also possible this is a sloppy declaration, in which case it will be\r\n                    // fixed at the end\r\n                    if (isParamTitle(this._title) && this._tag.type && this._tag.type.name) {\r\n                        this._extra.name = this._tag.type;\r\n                        this._tag.name = this._tag.type.name;\r\n                        this._tag.type = null;\r\n                    } else {\r\n                        if (!this.addError('Missing or invalid tag name')) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                } else {\r\n                    name = this._tag.name;\r\n                    if (name.charAt(0) === '[' && name.charAt(name.length - 1) === ']') {\r\n                        // extract the default value if there is one\r\n                        // example: @param {string} [somebody=John Doe] description\r\n                        assign = name.substring(1, name.length - 1).split('=');\r\n                        if (assign.length > 1) {\r\n                            this._tag['default'] = assign.slice(1).join('=');\r\n                        }\r\n                        this._tag.name = assign[0];\r\n\r\n                        // convert to an optional type\r\n                        if (this._tag.type && this._tag.type.type !== 'OptionalType') {\r\n                            this._tag.type = {\r\n                                type: 'OptionalType',\r\n                                expression: this._tag.type\r\n                            };\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n\r\n            return true;\r\n        };\r\n\r\n        TagParser.prototype.parseDescription = function parseDescription() {\r\n            var description = sliceSource(source, index, this._last).trim();\r\n            if (description) {\r\n                if ((/^-\\s+/).test(description)) {\r\n                    description = description.substring(2);\r\n                }\r\n                this._tag.description = description;\r\n            }\r\n            return true;\r\n        };\r\n\r\n        TagParser.prototype.parseCaption = function parseDescription() {\r\n            var description = sliceSource(source, index, this._last).trim();\r\n            var captionStartTag = '<caption>';\r\n            var captionEndTag = '</caption>';\r\n            var captionStart = description.indexOf(captionStartTag);\r\n            var captionEnd = description.indexOf(captionEndTag);\r\n            if (captionStart >= 0 && captionEnd >= 0) {\r\n                this._tag.caption = description.substring(\r\n                    captionStart + captionStartTag.length, captionEnd).trim();\r\n                this._tag.description = description.substring(captionEnd + captionEndTag.length).trim();\r\n            } else {\r\n                this._tag.description = description;\r\n            }\r\n            return true;\r\n        };\r\n\r\n        TagParser.prototype.parseKind = function parseKind() {\r\n            var kind, kinds;\r\n            kinds = {\r\n                'class': true,\r\n                'constant': true,\r\n                'event': true,\r\n                'external': true,\r\n                'file': true,\r\n                'function': true,\r\n                'member': true,\r\n                'mixin': true,\r\n                'module': true,\r\n                'namespace': true,\r\n                'typedef': true\r\n            };\r\n            kind = sliceSource(source, index, this._last).trim();\r\n            this._tag.kind = kind;\r\n            if (!hasOwnProperty(kinds, kind)) {\r\n                if (!this.addError('Invalid kind name \\'%0\\'', kind)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        };\r\n\r\n        TagParser.prototype.parseAccess = function parseAccess() {\r\n            var access;\r\n            access = sliceSource(source, index, this._last).trim();\r\n            this._tag.access = access;\r\n            if (access !== 'private' && access !== 'protected' && access !== 'public') {\r\n                if (!this.addError('Invalid access name \\'%0\\'', access)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        };\r\n\r\n        TagParser.prototype.parseThis = function parseThis() {\r\n            // this name may be a name expression (e.g. {foo.bar}),\r\n            // an union (e.g. {foo.bar|foo.baz}) or a name path (e.g. foo.bar)\r\n            var value = sliceSource(source, index, this._last).trim();\r\n            if (value && value.charAt(0) === '{') {\r\n                var gotType = this.parseType();\r\n                if (gotType && this._tag.type.type === 'NameExpression' || this._tag.type.type === 'UnionType') {\r\n                    this._tag.name = this._tag.type.name;\r\n                    return true;\r\n                } else {\r\n                    return this.addError('Invalid name for this');\r\n                }\r\n            } else {\r\n                return this.parseNamePath();\r\n            }\r\n        };\r\n\r\n        TagParser.prototype.parseVariation = function parseVariation() {\r\n            var variation, text;\r\n            text = sliceSource(source, index, this._last).trim();\r\n            variation = parseFloat(text, 10);\r\n            this._tag.variation = variation;\r\n            if (isNaN(variation)) {\r\n                if (!this.addError('Invalid variation \\'%0\\'', text)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        };\r\n\r\n        TagParser.prototype.ensureEnd = function () {\r\n            var shouldBeEmpty = sliceSource(source, index, this._last).trim();\r\n            if (shouldBeEmpty) {\r\n                if (!this.addError('Unknown content \\'%0\\'', shouldBeEmpty)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        };\r\n\r\n        TagParser.prototype.epilogue = function epilogue() {\r\n            var description;\r\n\r\n            description = this._tag.description;\r\n            // un-fix potentially sloppy declaration\r\n            if (isAllowedOptional(this._title) && !this._tag.type && description && description.charAt(0) === '[') {\r\n                this._tag.type = this._extra.name;\r\n                if (!this._tag.name) {\r\n                    this._tag.name = undefined;\r\n                }\r\n\r\n                if (!sloppy) {\r\n                    if (!this.addError('Missing or invalid tag name')) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return true;\r\n        };\r\n\r\n        Rules = {\r\n            // http://usejsdoc.org/tags-access.html\r\n            'access': ['parseAccess'],\r\n            // http://usejsdoc.org/tags-alias.html\r\n            'alias': ['parseNamePath', 'ensureEnd'],\r\n            // http://usejsdoc.org/tags-augments.html\r\n            'augments': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\r\n            // http://usejsdoc.org/tags-constructor.html\r\n            'constructor': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\r\n            // Synonym: http://usejsdoc.org/tags-constructor.html\r\n            'class': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\r\n            // Synonym: http://usejsdoc.org/tags-extends.html\r\n            'extends': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\r\n            // http://usejsdoc.org/tags-example.html\r\n            'example': ['parseCaption'],\r\n            // http://usejsdoc.org/tags-deprecated.html\r\n            'deprecated': ['parseDescription'],\r\n            // http://usejsdoc.org/tags-global.html\r\n            'global': ['ensureEnd'],\r\n            // http://usejsdoc.org/tags-inner.html\r\n            'inner': ['ensureEnd'],\r\n            // http://usejsdoc.org/tags-instance.html\r\n            'instance': ['ensureEnd'],\r\n            // http://usejsdoc.org/tags-kind.html\r\n            'kind': ['parseKind'],\r\n            // http://usejsdoc.org/tags-mixes.html\r\n            'mixes': ['parseNamePath', 'ensureEnd'],\r\n            // http://usejsdoc.org/tags-mixin.html\r\n            'mixin': ['parseNamePathOptional', 'ensureEnd'],\r\n            // http://usejsdoc.org/tags-member.html\r\n            'member': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\r\n            // http://usejsdoc.org/tags-method.html\r\n            'method': ['parseNamePathOptional', 'ensureEnd'],\r\n            // http://usejsdoc.org/tags-module.html\r\n            'module': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\r\n            // Synonym: http://usejsdoc.org/tags-method.html\r\n            'func': ['parseNamePathOptional', 'ensureEnd'],\r\n            // Synonym: http://usejsdoc.org/tags-method.html\r\n            'function': ['parseNamePathOptional', 'ensureEnd'],\r\n            // Synonym: http://usejsdoc.org/tags-member.html\r\n            'var': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\r\n            // http://usejsdoc.org/tags-name.html\r\n            'name': ['parseNamePath', 'ensureEnd'],\r\n            // http://usejsdoc.org/tags-namespace.html\r\n            'namespace': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\r\n            // http://usejsdoc.org/tags-private.html\r\n            'private': ['parseType', 'parseDescription'],\r\n            // http://usejsdoc.org/tags-protected.html\r\n            'protected': ['parseType', 'parseDescription'],\r\n            // http://usejsdoc.org/tags-public.html\r\n            'public': ['parseType', 'parseDescription'],\r\n            // http://usejsdoc.org/tags-readonly.html\r\n            'readonly': ['ensureEnd'],\r\n            // http://usejsdoc.org/tags-requires.html\r\n            'requires': ['parseNamePath', 'ensureEnd'],\r\n            // http://usejsdoc.org/tags-since.html\r\n            'since': ['parseDescription'],\r\n            // http://usejsdoc.org/tags-static.html\r\n            'static': ['ensureEnd'],\r\n            // http://usejsdoc.org/tags-summary.html\r\n            'summary': ['parseDescription'],\r\n            // http://usejsdoc.org/tags-this.html\r\n            'this': ['parseThis', 'ensureEnd'],\r\n            // http://usejsdoc.org/tags-todo.html\r\n            'todo': ['parseDescription'],\r\n            // http://usejsdoc.org/tags-typedef.html\r\n            'typedef': ['parseType', 'parseNamePathOptional'],\r\n            // http://usejsdoc.org/tags-variation.html\r\n            'variation': ['parseVariation'],\r\n            // http://usejsdoc.org/tags-version.html\r\n            'version': ['parseDescription']\r\n        };\r\n\r\n        TagParser.prototype.parse = function parse() {\r\n            var i, iz, sequences, method;\r\n\r\n\r\n            // empty title\r\n            if (!this._title) {\r\n                if (!this.addError('Missing or invalid title')) {\r\n                    return null;\r\n                }\r\n            }\r\n\r\n            // Seek to content last index.\r\n            this._last = seekContent(this._title);\r\n\r\n            if (this._options.range) {\r\n                this._tag.range = [this._first, source.slice(0, this._last).replace(/\\s*$/, '').length].map(convertIndex);\r\n            }\r\n\r\n            if (hasOwnProperty(Rules, this._title)) {\r\n                sequences = Rules[this._title];\r\n            } else {\r\n                // default sequences\r\n                sequences = ['parseType', 'parseName', 'parseDescription', 'epilogue'];\r\n            }\r\n\r\n            for (i = 0, iz = sequences.length; i < iz; ++i) {\r\n                method = sequences[i];\r\n                if (!this[method]()) {\r\n                    return null;\r\n                }\r\n            }\r\n\r\n            return this._tag;\r\n        };\r\n\r\n        function parseTag(options) {\r\n            var title, parser, tag;\r\n\r\n            // skip to tag\r\n            if (!skipToTag()) {\r\n                return null;\r\n            }\r\n\r\n            // scan title\r\n            title = scanTitle();\r\n\r\n            // construct tag parser\r\n            parser = new TagParser(options, title);\r\n            tag = parser.parse();\r\n\r\n            // Seek global index to end of this tag.\r\n            while (index < parser._last) {\r\n                advance();\r\n            }\r\n\r\n            return tag;\r\n        }\r\n\r\n        //\r\n        // Parse JSDoc\r\n        //\r\n\r\n        function scanJSDocDescription(preserveWhitespace) {\r\n            var description = '', ch, atAllowed;\r\n\r\n            atAllowed = true;\r\n            while (index < length) {\r\n                ch = source.charCodeAt(index);\r\n\r\n                if (atAllowed && ch === 0x40  /* '@' */) {\r\n                    break;\r\n                }\r\n\r\n                if (esutils.code.isLineTerminator(ch)) {\r\n                    atAllowed = true;\r\n                } else if (atAllowed && !esutils.code.isWhiteSpace(ch)) {\r\n                    atAllowed = false;\r\n                }\r\n\r\n                description += advance();\r\n            }\r\n\r\n            return preserveWhitespace ? description : description.trim();\r\n        }\r\n\r\n        function parse(comment, options) {\r\n            var tags = [], tag, description, interestingTags, i, iz;\r\n\r\n            if (options === undefined) {\r\n                options = {};\r\n            }\r\n\r\n            if (typeof options.unwrap === 'boolean' && options.unwrap) {\r\n                source = unwrapComment(comment);\r\n            } else {\r\n                source = comment;\r\n            }\r\n\r\n            originalSource = comment;\r\n\r\n            // array of relevant tags\r\n            if (options.tags) {\r\n                if (Array.isArray(options.tags)) {\r\n                    interestingTags = { };\r\n                    for (i = 0, iz = options.tags.length; i < iz; i++) {\r\n                        if (typeof options.tags[i] === 'string') {\r\n                            interestingTags[options.tags[i]] = true;\r\n                        } else {\r\n                            utility.throwError('Invalid \"tags\" parameter: ' + options.tags);\r\n                        }\r\n                    }\r\n                } else {\r\n                    utility.throwError('Invalid \"tags\" parameter: ' + options.tags);\r\n                }\r\n            }\r\n\r\n            length = source.length;\r\n            index = 0;\r\n            lineNumber = 0;\r\n            recoverable = options.recoverable;\r\n            sloppy = options.sloppy;\r\n            strict = options.strict;\r\n\r\n            description = scanJSDocDescription(options.preserveWhitespace);\r\n\r\n            while (true) {\r\n                tag = parseTag(options);\r\n                if (!tag) {\r\n                    break;\r\n                }\r\n                if (!interestingTags || interestingTags.hasOwnProperty(tag.title)) {\r\n                    tags.push(tag);\r\n                }\r\n            }\r\n\r\n            return {\r\n                description: description,\r\n                tags: tags\r\n            };\r\n        }\r\n        exports.parse = parse;\r\n    }(jsdoc = {}));\r\n\r\n    exports.version = utility.VERSION;\r\n    exports.parse = jsdoc.parse;\r\n    exports.parseType = typed.parseType;\r\n    exports.parseParamType = typed.parseParamType;\r\n    exports.unwrapComment = unwrapComment;\r\n    exports.Syntax = shallowCopy(typed.Syntax);\r\n    exports.Error = utility.DoctrineError;\r\n    exports.type = {\r\n        Syntax: exports.Syntax,\r\n        parseType: typed.parseType,\r\n        parseParamType: typed.parseParamType,\r\n        stringify: typed.stringify\r\n    };\r\n}());\r\n/* vim: set sw=4 ts=4 et tw=80 : */\r\n"],
  "mappings": "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",
  "names": ["previous", "index", "token", "value", "hasOwnProperty", "exports", "index", "parse"]
}
